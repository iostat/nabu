package io.stat.nabuproject.core.net;

import com.google.common.collect.Lists;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.handler.codec.DecoderException;
import lombok.experimental.UtilityClass;

import java.io.Serializable;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.util.List;

/**
 * Provides some helper functions for the network protocol that Nabu uses to communicate between
 * the server and clients, as well as internal communication between Enki and Nabu(s).
 *
 * @author Ilya Ostrovskiy (https://github.com/iostat/)
 */
@UtilityClass
public class ProtocolHelper {
    private static final Charset UTF_8 = Charset.forName("UTF-8");
    public static final String READ_STRING_NO_SIZE = "Don't have enough data available to determine a String length";
    public static final String READ_STRING_TOO_SHORT = "Don't have enough data to read the whole string";

    /**
     * Converts a {@link String} into a series of bytes that can be reconstructed
     * {@link ProtocolHelper#readStringFromByteBuf(ByteBuf)}
     * @param s the string to encode
     * @param out the {@link ByteBuf} to write to
     */
    public static void writeStringToByteBuf(String s, ByteBuf out) {
        ByteBuf encodedString = ByteBufUtil.encodeString(UnpooledByteBufAllocator.DEFAULT, CharBuffer.wrap(s), UTF_8);
        int size = encodedString.readableBytes();

        out.writeInt(size);
        out.writeBytes(encodedString);
        encodedString.release();
    }

    /**
     * Converts a series of bytes generated by {@link ProtocolHelper#writeStringToByteBuf(String, ByteBuf)}
     * into a {@link String}
     * @param in a {@link ByteBuf} containing data to reconstuct into a String, ideally
     *           created by {@link ProtocolHelper#writeStringToByteBuf(String, ByteBuf)} on the other end
     * @return the reconstructed {@link String}
     * @throws DecoderException if there isn't enough data in the buffer to reconstruct the original String
     */
    public static String readStringFromByteBuf(ByteBuf in) throws DecoderException {
        if(in.readableBytes() < 4) {
            throw new DecoderException(READ_STRING_NO_SIZE);
        }

        int size = in.readInt();

        if(in.readableBytes() < size) {
            throw new DecoderException(READ_STRING_TOO_SHORT);
        }

        ByteBuf stringBuf = Unpooled.buffer();
        in.readBytes(stringBuf, size);

        String ret = stringBuf.toString(UTF_8);
        stringBuf.release();

        return ret;
    }

    /**
     * Convert a Netty ByteBuf into a byte[], and then release the ByteBuf.
     * As release implies, do not attempt to use the buffer afterwards as you
     * will have a bad day.
     * @param buffer The ByteBuf to convert
     * @return A byte[] containing the ByteBuf's contents.
     */
    public static byte[] convertAndRelease(ByteBuf buffer) {
        byte[] dest = new byte[buffer.readableBytes()];
        buffer.getBytes(0, dest);
        buffer.release();

        return dest;
    }

    /**
     * Write a Serializable into a ByteBuf, using {@link ObjectEncoderExposer}
     * @param o the Serializable to write
     * @param dest the ByteBuf to write to
     * @throws Exception if any Exception bubbled up from {@link ObjectEncoderExposer}
     */
    public static void writeSerializableToByteBuf(Serializable o, ByteBuf dest) throws Exception {
        new ObjectEncoderExposer().exposeEncode(null, o, dest);
    }

    public static <T extends Serializable> T readSerializableFromByteBuf(ByteBuf in) throws Exception {
        List<Object> out = Lists.newArrayList(2);
        new ObjectDecoderExposer().exposeDecode(null, in, out);


        //noinspection unchecked assuming this is used properly, the cast shouldnt be an issue
        return (T) out.get(1);
        // the real issue is why exposeDecode starts at index 1 :/
    }
}

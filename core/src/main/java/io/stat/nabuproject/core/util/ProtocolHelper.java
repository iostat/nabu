package io.stat.nabuproject.core.util;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufUtil;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.handler.codec.DecoderException;
import lombok.experimental.UtilityClass;

import java.nio.CharBuffer;
import java.nio.charset.Charset;

/**
 * Provides some helper functions for the network protocol that Nabu uses to communicate between
 * the server and clients, as well as internal communication between Enki and Nabu(s).
 *
 * @author Ilya Ostrovskiy (https://github.com/iostat/)
 */
@UtilityClass
public class ProtocolHelper {
    private static final Charset UTF_8 = Charset.forName("UTF-8");

    /**
     * Converts a {@link String} into a series of bytes that can be reconstructed
     * {@link ProtocolHelper#readStringFromByteBuf(ByteBuf)}
     * @param s the string to encode
     * @param out the {@link ByteBuf} to write to
     */
    public static void writeStringToByteBuf(String s, ByteBuf out) {
        ByteBuf encodedString = ByteBufUtil.encodeString(UnpooledByteBufAllocator.DEFAULT, CharBuffer.wrap(s), UTF_8);
        int size = encodedString.readableBytes();

        out.writeInt(size);
        out.writeBytes(encodedString);
    }

    /**
     * Converts a series of bytes generated by {@link ProtocolHelper#writeStringToByteBuf(String, ByteBuf)}
     * into a {@link String}
     * @param in a {@link ByteBuf} containing data to reconstuct into a String, ideally
     *           created by {@link ProtocolHelper#writeStringToByteBuf(String, ByteBuf)} on the other end
     * @return the reconstructed {@link String}
     * @throws DecoderException if there isn't enough data in the buffer to reconstruct the original String
     */
    public static String readStringFromByteBuf(ByteBuf in) throws DecoderException {
        if(in.readableBytes() < 4) {
            throw new DecoderException("Don't have enough data available to determine a String length");
        }

        int size = in.readInt();

        if(in.readableBytes() < size) {
            throw new DecoderException("Don't have enough data to read the whole string");
        }

        ByteBuf stringBuf = Unpooled.buffer();
        in.readBytes(stringBuf, size);

        return stringBuf.toString(UTF_8);
    }

    /**
     * Convert a Netty ByteBuf into a byte[], and then release the ByteBuf.
     * As release implies, do not attempt to use the buffer afterwards as you
     * will have a bad day.
     * @param buffer The ByteBuf to convert
     * @return A byte[] containing the ByteBuf's contents.
     */
    public static byte[] convertAndRelease(ByteBuf buffer) {
        byte[] dest = new byte[buffer.readableBytes()];
        buffer.getBytes(0, dest);
        buffer.release();

        return dest;
    }
}

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath('com.github.jengelman.gradle.plugins:shadow:1.2.2')
        classpath('com.netflix.nebula:gradle-aggregate-javadocs-plugin:2.2.+')
    }
}

// aggregate javadocs from all subprojects into build/docs/javadocs
//apply plugin: 'nebula-aggregate-javadocs'

// need to put lombok here because IDEA doesn't have "module classpath" annotation processing
// aka LAME
allprojects {
    group 'io.stat.nabuproject'
    version '0.1-SNAPSHOT'

//    apply(plugin: 'idea')

    project.ext.delombokPath = "${project.buildDir}/delombok/main/java"
}

subprojects {
    apply(plugin: 'com.github.johnrengelman.shadow')

    // for per-environment config file packaging.
    project.ext.projectPath = project.file(".").absolutePath
    project.ext.buildEnvironment = project.hasProperty('env') ? env : 'dev'

    // Lovingly borrowed from
    // http://tobiasbayer.com/blog/2011/04/16/building-for-different-environments-with-gradle/
    task copyConfiguration {
        outputs.upToDateWhen { false }
        doLast {
            println "Target build environment: $buildEnvironment"
            copy {
                from "$projectPath/src/main/env/$buildEnvironment"
                into "$projectPath/src/main/resources"
                include "*/"
            }
        }
    }

    apply(plugin: 'java')
    sourceCompatibility = 1.8

    repositories {
        mavenLocal()
        mavenCentral()
    }

    // Delete the stuff copied into src/main/resources per-env
    // note this is different from cleanCopyConfiguration, which is auto-
    // generated by gradle to clean the UPTODATE flag from copyConfiguration
    task cleanCopiedConfiguration(dependsOn: cleanCopyConfiguration) {
        outputs.upToDateWhen { false }

        doLast {
            delete fileTree(dir: "$projectPath/src/main/resources", exclude: ".keep")
            delete fileTree(dir: "$projectPath/build/resources")
        }
    }

    // :X
    project.build.dependsOn(copyConfiguration)
    project.buildNeeded.dependsOn(copyConfiguration)
    project.buildDependents.dependsOn(copyConfiguration)
    project.compileJava.dependsOn(copyConfiguration)
    project.jar.dependsOn(copyConfiguration)
    project.shadowJar.dependsOn(copyConfiguration)
    project.processResources.dependsOn(copyConfiguration)
    project.classes.dependsOn(copyConfiguration)
    project.clean.dependsOn(cleanCopiedConfiguration)
    project.copyConfiguration.dependsOn(cleanCopyConfiguration)

    jar {
        // when doing `gradle jar`, the output will be
        // "build/libs/baseName-version-tag.jar
        // this sets baseName to `nabuproject-dev` or `nabuproject-prod`
        // depending on what -Penv= was passed when building
        baseName = "${baseName}-${project.ext.buildEnvironment}"
    }

    shadowJar {
        // when doing `gradle shadowJar`, the output will be
        // "build/libs/baseName-version-tag-all.jar
        // this sets baseName to `nabuproject-dev` or `nabuproject-prod`
        // depending on what -Penv= was passed when building
        baseName = "${baseName}-${project.ext.buildEnvironment}"

        mergeServiceFiles()
    }

    configurations {
        lombok
    }

    dependencies {
        // all of these external deps are common amongst nabu, enki, and the client.

        lombok (group: 'org.projectlombok', name: 'lombok', version: '1.16.6')
        compile configurations.lombok.dependencies

        // guice depends on guava anyway, and we might get some use of it.
        compile(group: 'com.google.guava', name: 'guava', version: '19.0')

        // async networking ftw
        compile(group: 'io.netty', name: 'netty-all', version: '4.0.33.Final')

        // slf4j logging.
        compile(group: 'org.slf4j', name: 'slf4j-api', version:'1.7.13')

        // Koloboke Collections (used by client currently, and eventually by everything else)
        compile(group: 'net.openhft', name: 'koloboke-api-jdk8', version:'0.6.8')
        runtime(group: 'net.openhft', name: 'koloboke-impl-jdk8', version:'0.6.8')
    }

    sourceSets {
        delombok {
            java {
                srcDir project.ext.delombokPath
            }
        }
    }

    task delombok {
        inputs.files project.sourceSets.main.allJava
        outputs.dir file(project.ext.delombokPath)

        doLast {
            FileCollection collection = files(configurations.compile)
            FileCollection sumTree = collection + fileTree(dir: 'bin')

            ant.taskdef(name: 'delombok', classname: 'lombok.delombok.ant.Tasks$Delombok', classpath: configurations.lombok.asPath)
            ant.delombok(from: "${project.projectDir}/src/main/java", to: project.ext.delombokPath, classpath: sumTree.asPath)
        }
    }

//    // thank you intellij for wasting many hours of my life
//    idea {
//        module {
//            downloadJavadoc = true
//            downloadSources = true
//
//            sourceDirs += file('src/main/env')
//
//            // at this stage we appended our "src/main/env" to all kno
//            println("preflight: $project.name has ::S: $sourceDirs ::G: $generatedSourceDirs")
//
//            // even the most perfect software has a fatal flaw
//            // and IntelliJ's is the fact that gradle's duct-taped to
//            // their build system
//            iml {
//                beforeMerged { mod ->
//                    println "start beforeMerge: $project.name has ::S: $mod.sourceFolders ::G: $mod.generatedSourceFolders"
//
//                    // apparently the org.gradle.plugin.ide.idea.module.Path doesnt implement .equals() or
//                    // a correct fucking .hashCode or fucking something AND THEY USE A LINKEDHASHSET
//                    // so you have a fucking ***SET*** of paths gets duplicates, intellij's
//                    // SHIT GRADLE API DOESN'T AND CANT check for this, and that's why your custom
//                    // XML changes only stick for 10 seconds or one sync with gradle, and why intellij has the helpful
//                    // message IML HAS BEEN TRUNCATED instead of "THERE IS GARBAGE/DUPLICATED DATA IN IT BECAUSE
//                    // WE ARE INTELLIJENT BUT REALLY ITS NOT OUR FAULT WE CANT CODE SO WE'LL TELL YOU THE FILE GOT SMALLER
//                    // EVEN THOUGH IT TECHNICALLY GOT BIGGER BECAUSE FUCK YOU THATS WHY"
//                    def deduplicatedSourceFolders = []
//                    mod.sourceFolders.forEach({f ->
//                        // amazingly enough in my findings, AFTER I manually set src/main/resources as
//                        // autogenned on subsequent runs of gradle :idea it picks that fact up correctly.
//                        if(f.url.endsWith("src/main/resources")) {
//                            // BALEETED, we don't need in the main source set, it should be treated like
//                            // the autogenerated scum it is
//                            println("BALEETED $f")
//                        } else {
//                            // AND NOW WE O(N^2) LIKE THE FUCKWITS WE ARE
//                            // cause you know, hashCodes are hard, or something?
//                            for(org.gradle.plugins.ide.idea.model.Path inDedup : deduplicatedSourceFolders) {
//                                if(f.url.equals(inDedup.url)) {
//                                    println("GTFO DUPLICATE $f")
//                                    continue
//                                }
//                            }
//                            deduplicatedSourceFolders += f
//                        }
//                    })
//
//                    // yes you have to do a clear first, because groovy tries so hard to be so fancy that
//                    // ultimately an assignment to sourceFolders is actually calling setSourceFolders WHICH OF COURSE THE
//                    // WERE-SO-MUCH-MORE-INTELLIJ-THAN-YOU DEVELOPERS decide that this setter should actually APPEND
//                    // to a SET<> and ALLOW DUPLICATES IN THE PROCESS #genius #perf #justcompscigraduatethingz
//                    mod.sourceFolders.clear()
//                    mod.sourceFolders = deduplicatedSourceFolders
//                    println "after beforeMerge: $project.name has ::S: $mod.sourceFolders ::G: $mod.generatedSourceFolders"
//                }
//
//                whenMerged { mod ->
//                    println "whenMerged (noop, should be beforeMerge + preflight): $project.name has ::S: $mod.sourceFolders ::G: $mod.generatedSourceFolders"
//
//                    // hilarious retarded bug that probably happens either here or in xmlgen. someone decides that
//                    // src/main/env should be both a resource directory, as well as a test source code directory
//                    // intellij finds nothing wrong with this and happily highlights the whole folder as green
//                    // while giving it a resource icon
//                    // 10/10 would quality assurance again.
//                    println "wm $project.name testz START :: $mod.testSourceFolders"
//                    def doubleDigitIQCompensation = []
//                    mod.testSourceFolders.forEach({ tsf ->
//                        if(tsf.url.equals('file://$MODULE_DIR$/src/main/env') || tsf.url.equals('file://$MODULE_DIR$/src/main/resources')) {
//                            println "WHO YOU GONNA CALL? disgruntled open source developers! $tsf"
//                        } else {
//                            for(org.gradle.plugins.ide.idea.model.Path inDedup : doubleDigitIQCompensation) {
//                                if(tsf.url.equals(inDedup.url)) {
//                                    println("GTFO DUPLICATE $tsf")
//                                    continue
//                                }
//                            }
//                            doubleDigitIQCompensation += tsf
//                        }
//                    })
//                    mod.testSourceFolders.clear()
//                    mod.testSourceFolders += doubleDigitIQCompensation
//                    println "wm $project.name testz END :: $mod.testSourceFolders"
//                }
//
//                withXml { xml ->
//                    def node = xml.asNode().component.content
//                    def envAttrs = node.sourceFolder
//                            .find() { it.@url == 'file://$MODULE_DIR$/src/main/env' }?.attributes()
//                    envAttrs?.put('type', 'java-resource')
//                    envAttrs?.put('isTestSource', 'false')
//
//                    println ("env  $project.name ::  $envAttrs")
//
//                    def rsrcAttrs = node.sourceFolder
//                            .find() { it.@url == 'file://$MODULE_DIR$/src/main/resources' }?.attributes()
//
//                    rsrcAttrs?.remove('type')
//                    rsrcAttrs?.put('isTestSource', 'false')
//                    rsrcAttrs?.put('generated', 'true')
//
//                    println ("rsrc $project.name ::  $rsrcAttrs")
//                }
//            }
//        }
//    }
}

task docs(type: Javadoc) {
    source (subprojects.collect
            {project -> project.sourceSets.delombok.allJava })

    dependsOn(subprojects.collect
            {project -> project.tasks.delombok})

    classpath = (files(subprojects.collect
            {project -> project.sourceSets.main.compileClasspath}))
    destinationDir = new File(projectDir, 'docs')

    // cause there are some sneaky throws, and weird lombok annotations
    // and JDK8's doclint is suuuuuuper strict
    failOnError = false

    // link to standard javadocs where needed
    // and ES docs
    // and probably kafka
    // and guice
    options.setLinks(["https://docs.oracle.com/javase/8/docs/api/",
                      "https://google.github.io/guice/api-docs/4.0/javadoc/",
                      "https://google.github.io/guava/releases/19.0/api/docs/",
                      "http://javadoc.kyubu.de/elasticsearch/v2.1.0/",
                      "http://kafka.apache.org/082/javadoc/"
    ])

    options.author = true
}

task jenkins(dependsOn: [":client:publishToMavenLocal", ":enki:shadowJar", ":nabu:shadowJar"]) << {
    exec {
        executable "docker"
        args 'rmi', 'srnk.io/svcs/nabu:0.1'
        ignoreExitValue = true
    }

    exec {
        executable "docker"
        args 'build', '-t', 'srnk.io/svcs/nabu:0.1', '.'
    }

    exec {
        executable "docker"
        args 'push', 'srnk.io/svcs/nabu:0.1'
    }
}
